# 函数

**函数的意义和定位**

1. 帮助我们快速、优雅的去实现代码的复用

**函数的执行规则**

1. 调用函数之后，回到函数定义的地方去执行函数体的内容，随后继续往下面执行代码
2. 调用函数时，实参的具体参数会传递给函数形参，从而给函数体使用

## 函数的语法

```
function 函数名 (形参1，形参2,...) {
  // 函数体的执行内容
}

// 参数调用
函数名(实参1， 实参2， ...)
```

## 函数的参数

### 形参

**形式上的参数，没有具体的数值，只是一个占位符号，它是存在于函数定义的地方 和 函数体里面的内容**

1. 函数的括号里面可以使用自定义变量名的形式创建一个形参

### 实参

**实际上存在的参数，是有具体的数值，他是存在于函数调用的地方**

2. 调用函数的括号里面可以传入实际的参数传递给形参，而调用语句括号里面写的参数称为实参

### 参数的情况

-   形参个数 > 实参个数
    -   实参覆盖从左到右去进行，如果没有覆盖的就是 nudefined
-   形参个数 < 实参个数
    -   多余的实参没有作用，会被忽略。只会按照从左到右的去按照形参个数去拿实参的个数
    -   当出现没有形参的时候，即使设置了实参，同样没有作用，会被忽略
-   形参个数 = 实参个数
    -   正常执行

### 不定参 arguments

> 不定餐：在实际过程中，我们有的无法判断参数的数量

-   **设置不定参**
    -   就在函数体中直接打印输出 arguments 即可
-   **使用不定参**
    -   可以通过下标来获取所有的参数

> arguments 是专门用来获取函数中的实参，是一个系统自带的一个伪数组（类数组）（不需要我们去定义）

**伪数组**

-   伪数组
    -   类似数组的东西 可以通过下标访问到对应的元素
    -   也有长度
    -   （关键）正常的数组是有 push() pop() shift()，伪数组是没有以上方法的

```
function countSum(num) {
  var sum = 0
  for (var i = 1; i <= num; i++) {
      sum += i
  }
  console.log(sum)
}

countSum(10)
```

## 函数的调用

1. 如果去写一个函数（三个步骤）
    - 通过关键字`function`定义函数
    - 在函数体中写具体的逻辑操作
    - 一定要记得调用函数

```
function countSum() {
      var sum = 0
      for (var i = 1; i <= 100; i++) {
          sum += i
      }
      console.log(sum)
  }
// 可以使用函数名 + () 调用函数
      countSum()
```

## 函数的返回值

**通过 return 关键字返回的内容，叫做函数的返回值**

> 返回值的设置是根据需求来的，不是一定写的语法规范
> 可以在函数体中使用`return`关键字返回一个值（返回值），这个值会返回到调用函数的语句中输出

**注意：**

1. return 可以不设置返回内容，可以充当终止函数执行的关键字
2. 如果不设置 return 函数执行完毕后会自动返回 undefined

```
function countSum(num) {
    var sum = 0
    for (var i = 1; i <= num; i++) {
        sum += i
    }
    console.log(sum)
    return sum;
}

var a = countSum(10)
var a = countSum(100)
```

# 函数进阶

> 在实际开发中，随着代码越来越多，即使封装成了函数，但是也会出现嵌套函数的情况

## 函数普通嵌套

```
var total = 0
function add(num) {
    for (var i = 0; i <= num; i++) {
        total += num
    }
    console.log(total)
    return total
}

// 专门用来做累乘 返回一个结果
function mutiple(num) {
    total = 1
    for (var i = 0; i < num; i++) {
        total *= num
    }
    console.log(total)
    return total
}

console.log(add(4), mutiple(3))

// 专门用来判断奇偶数的
function odd(num) {
    if (num % 2 == 0) {
        return mutiple(num)
    } else {
        return add(num)
    }
}

console.log(odd(4))
```

## 函数递归（函数嵌套）自己调用自己

```
function fn(num) {
  num--
  console.log(num)
  fn(num)
}
fn(10)

// 报错Maximum call stack size exceeded
```

**注意：Maximum call stack size exceeded，指的是栈溢出**

> 解决办法可以设置一个出口，或者说设置一个终止条件，基本上就是一个判断，判断完之后一定要 + return （终止函数的执行）

```
function fn(num) {
    num--
    if (num == 0) {
        return
    }
    console.log(num)
    fn(num)
}
fn(10)
```
