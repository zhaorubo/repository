-   三座大山：
    -   作用域与闭包
    -   同步与异步
    -   对象与原型

# 作用域

> 概念： 通常来说，一段程序所用到的名字(变量或函数)从定义到结束标签中间的区域就是作用域

## 全局作用域(ES5)

> 一个 html 中一对 Script 标签就是一个全局作用域。或者一个 js 文件就是一个全局作用域，**_全局作用域中的变量会在关闭浏览器的时候释放_**

## 局部作用域(ES5)

> 又名函数作用域，局部作用域的变量会在函数执行完毕之后会被**释放**（删除变量）

## 块级作用域(ES6)

> 一个花括号里面就是一个块级作用域

```
if(true) {
  let a = 1
  console.log(a)
}
console.log(a)
```

## 作用域链

> 作用域链：是变量向上级作用域访问的过程
> 规则： 执行变量相关操作的时候，先找自己的作用域，如果没有，再往上一层作用域查找，如果没有再向上，直到找到全局为止，如果直到全局都没有直接报错

```
 var a = 1
var b = 100
function fn() {
    //  函数体 内部 就是 局部作用域
    var b = 2
    function fn2() {
        console.log(b)
    }
    fn2()
}
fn()

```

## 作用域链的应用（闭包）**重点**

> 概念：闭包是一个函数，它是函数中的特殊应用。 **就是一个有权访问(按照作用域链的机制)另外一个函数作用域的函数**

### 使用场景

#### **场景 1**

> 函数作为参数被传递

```
// 函数作为参数被传递
            function fn(fn1) {
                var a = 200
                fn1()
            }
            var a = 100
            function fn1() {
                // fn1 没有定义 a
                console.log(a) // 100
            }
            fn(fn1)
```

#### **场景 2**

> 函数作为返回值被返回

```
// 函数作为返回值被返回
            function fn2() {
                var b = 200
                return function () {
                    console.log(b) // 200
                }
            }
            var b = 100
            var c = fn2()
            c()
```

> **上述两种场景，关键在于都要看函数定义的地方，变量向上级查找不要看函数调用的地方**

> 特点：闭包中使用的变量是不会被释放的，一直到关闭浏览器才会释放
> **注意**：局部变量不会因为不被释放而变成全局变量
> 缺点：造成内存泄漏

```
 // 闭包中使用的变量是不会被释放的，一直到关闭浏览器才会释放
function fn() {
    var a = 'alex'
    function fn1() {
        a += ' 6'
        console.log(a)
    }
    return fn1
}
var fn3 = fn()
fn3() // alex 6
fn3() // alex 6 6
fn3() // alex 6 6 6
```

### 实际场景 与 立即执行函数

```
立即执行函数 语法：
  // (function (形参1，形参2，...) {
  // 函数体
  // })(实参1，实参2，...)
```
