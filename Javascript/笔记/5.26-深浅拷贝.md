# 深浅拷贝

-   问题

    -   数组 或者 对象 当我们进行 = 赋值之后，修改数据之后会影响之前的数据

-   为什么会造成这个问题？
    1. 简单数据类型是存放在 **栈内存**
    2. 引用数据类型是存放在 **堆内存**
    
    > var let const 这个关键字 会在栈内存中开辟空间
    > 当计算机发现你的数据类型是引用数据类型之后，先在堆内存中存放数据，然后把对应的内存地址，放在栈内存中，当访问 obj 或者 arr 的时候，访问的是栈内存中的堆内存地址，之后，根据地址找内容
    
    > 如果是简单数据类型通过等号赋值，进行值的拷贝.
    >
    > 如果是 引用数据类型通过 等号赋值，进行地址拷贝
    
    
    
- 解决方法是什么

  		1. 在堆内存中开辟一个新空间

  2. 把对应的内存拷贝到新空间中







## 如何判断引用数据类型

> 通过关键字 `instanceof` 判断当前的变量是不是来自于对应的构造函数

```
let arr = [1,2,3]
let obj = {a:1}

console.log(obj instanceof Object) // true
console.log(arr instanceof Object) // true

console.log(arr instanceof Array) // true
console.log(obj instanceof Array) // false
```



- 如何去判断一个数据类型是数组还是对象呢？

  ```
  let item = []
  // 定义一个函数，作用输出当前的变量是什么数据类型
  function fn(item) {
  if(item instanceof Array) {
  		// 数组
  		console.log('数组')
  	}else if(item instanceof Object) {
  		// 对象
  		console.log('对象')
  	}else {
  		// 简单数据类型
  		console.log('简单')
  	}
  }
  fn(item)
  ```

  



## 浅拷贝

> 浅拷贝指的是拷贝对象或者数组中第一层数据结构
>
> `obj:{a:1,b:{c:1}} `   a:1 第一层 b:出现嵌套的格式，第二层，如此类推

```
 function deepClone(oldObj, newObj) {
                for (let key in oldObj) {
                    let item = oldObj[key] // item 是 obj 的属性值
                    if (item instanceof Array) {
                        // 数组
                        console.log('数组')
                    } else if (item instanceof Object) {
                        // 对象
                        console.log('对象')
                    } else {
                        // 简单数据类型
                        console.log('简单')
                        newObj[key] = item
                    }
                }
            }

            let obj = {
                name: 'alex',
                age: 18
                // color: ['red', 'white', 'blue']
            }

            let newObj
            deepClone(obj, newObj)
            console.log(newObj)
            newObj.age = 20
            console.log(obj)
            console.log(newObj)
```

## 深拷贝

> 深拷贝指的是拷贝第二层甚至更深层次的数据结构

```
 function deepClone(oldObj, newObj) {
                for (let key in oldObj) {
                    let item = oldObj[key] // item 是 obj 的属性值
                    if (item instanceof Array) {
                        // 数组
                        console.log('数组')
                        // 同样去开辟一个空间
                        newObj[key] = []
                        // 然后再去走deepClone的逻辑
                        deepClone(newObj[key], item)
                    } else if (item instanceof Object) {
                        // 对象
                        console.log('对象')
                        newObj[key] = {}
                        deepClone(newObj[key], item)
                    } else {
                        // 简单数据类型
                        console.log('简单')
                    }
                }
            }

            let obj = {
                name: 'alex',
                age: 18,
                color: ['red', 'white', 'blue'],
                food: {
                    banner: '香蕉',
                    apple: '苹果'
                }
            }
            let newObj
            deepClone(obj, newObj)
            newObj.food.banner = '雪梨'
            console.log(obj)
            console.log(newObj)
```

